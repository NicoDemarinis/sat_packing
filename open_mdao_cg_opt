import numpy as np
import openmdao.api as om
import trimesh.collision as tc
from trimesh_env_setup_cg import get_cg

#  LayoutCost Component
class LayoutCost(om.ExplicitComponent):

    def initialize(self):
        self.options.declare("scene", types=dict)
        self.options.declare("cg_min", default=[0, 0, 0])
        self.options.declare("cg_max", default=[1e6, 1e6, 1e6])

    def setup(self):
        scene = self.options["scene"]
        self.N = len(scene["components"])

        # design variables: translations of each component
        self.add_input("p", shape=(self.N, 3))
        self.add_output("J", val=0.0)

        # finite-difference partials
        self.declare_partials(of="J", wrt="p", method="fd", step=5.0)

    def compute(self, inputs, outputs):
        scene = self.options["scene"]
        ENV = scene["envelope_size_mm"]
        Ex, Ey, Ez = ENV
        epsilon = float(scene["epsilon_mm"])
        comps = scene["components"]
        N = self.N
        
        # Setting up CG bounds
        cg_min = np.asarray(self.options["cg_min"], float) 
        cg_max = np.asarray(self.options["cg_max"], float)

        p = np.asarray(inputs["p"], float)

        # Extract masses + local CGs
        masses = np.array([c["mass"] for c in comps], float)
        cg_local = np.array([c["cg_local_mm"] for c in comps], float)

        # 1. Wall Clearance Penalty
        # ------------------------------------------------------
        pen_wall = 0.0
        for i, comp in enumerate(comps):
            bmin_local, bmax_local = comp["bounds_local"]

            # Translate to global bounds
            bmin = bmin_local + p[i]
            bmax = bmax_local + p[i]

            # epsilon <= bmin
            lo_viol = epsilon - bmin
            # bmax <= ENV - epsilon
            hi_viol = bmax - (ENV - epsilon)

            pen_wall += np.sum(np.maximum(0, lo_viol)**2 +
                               np.maximum(0, hi_viol)**2)

        # 2. Component–Component Collisions
        # ------------------------------------------------------
        cm = tc.CollisionManager()
        for i, comp in enumerate(comps):
            m = comp["mesh"].copy()
            m.apply_translation(p[i])
            cm.add_object(comp["name"], m)

        pen_col = 0.0
        hit, pairs = cm.in_collision_internal(return_names=True)
        if hit:
            pen_col = len(pairs)**2 # len(pairs) is just the number of component-component collision
            # We want that to be 0

        # 3. Global CG Constraint
        # ------------------------------------------------------
        cg_global = (masses[:, None] * (cg_local + p)).sum(axis=0) / masses.sum()

        cg_lo_viol = cg_min - cg_global
        cg_hi_viol = cg_global - cg_max

        pen_cg = np.sum(np.maximum(0, cg_lo_viol)**2 +
                        np.maximum(0, cg_hi_viol)**2)

        # 4.    Final Cost
        # ------------------------------------------------------
        w_wall = 1.0
        w_col = 1000.0 #bumped this up because things are hitting
        w_cg = 100.0
        w_reg = 1e-6 # Don’t move components more than you need to

        J = (w_wall * pen_wall +
             w_col * pen_col +
             w_cg * pen_cg ) #+
             #w_reg * np.sum(p**2))

        outputs["J"] = J


#  OPTIMIZATION
def main():

    # Load scene from trimesh environment 
    scene = get_cg(visualize=False)

    ENV = scene["envelope_size_mm"]
    Ex, Ey, Ez = ENV
    epsilon = float(scene["epsilon_mm"])

    components = scene["components"]
    N = len(components)

    # Design Variable Bounds 
    lower = np.zeros((N, 3))
    upper = np.zeros((N, 3))
    for i, c in enumerate(components):
        bmin_local, bmax_local = c["bounds_local"]
        lower[i, :] = epsilon - bmin_local
        upper[i, :] = (ENV - epsilon) - bmax_local

    # Start from user-provided offsets as initial guess
    p0 = np.vstack([np.array(c["xyz0_mm"]) for c in components])

    # Optional CG region - edit base on spaceX rideshare rules
    # cg_min = np.array([0.2 * Ex, 0.2 * Ey, 0.2 * Ez])
    # cg_max = np.array([0.8 * Ex, 0.8 * Ey, 0.8 * Ez])
    cg_min = np.array([340, 450, 250])
    cg_max = np.array([360, 500, 350])

    # OpenMDAO Problem 
    prob = om.Problem()

    ivc = om.IndepVarComp()
    ivc.add_output("p", p0)

    prob.model.add_subsystem("ivc", ivc, promotes=["*"])
    prob.model.add_subsystem(
        "layout",
        LayoutCost(scene=scene, cg_min=cg_min, cg_max=cg_max),
        promotes=["*"]
    )

    # Design variables
    axis_scale = 1.0 / np.maximum(ENV, 1.0)   # (3,)
    scaler = np.tile(axis_scale, (N, 1))      # (N,3)
    prob.model.add_design_var("p", lower=lower, upper=upper, scaler=scaler)

    # Objective
    prob.model.add_objective("J")

    # Use finite-difference total derivatives
    prob.model.approx_totals(method="fd", step=1.0) # Step size to limit big changes

    # Solver/optimizer
    prob.driver = om.ScipyOptimizeDriver()
    prob.driver.options["optimizer"] = "SLSQP"
    prob.driver.options["tol"] = 1e-6
    prob.driver.opt_settings["maxiter"] = 200
    prob.driver.opt_settings["eps"] = 10.0
    prob.driver.opt_settings["disp"] = True

    # Run 
    prob.setup()

    print("\n=== Initial ===")
    prob.run_model()
    print("J0:", prob.get_val("J"))

    prob.run_driver()

    p_star = prob.get_val("p")
    J_star = prob.get_val("J")

    print("\n=== Optimized Positions ===")
    for i, comp in enumerate(components):
        print(f"{comp['name']}: {p_star[i]} mm")

    print("Final cost J* =", J_star)
    
if __name__ == "__main__":
    main()
